---
name: smart-plan
description: |
  タスクを分解し、各サブタスクに Haiku/Sonnet の難易度を割り当てて計画ファイルを生成し、適切なモデルで実装する。
  トリガー: "計画を立てて", "タスクを分解", "smart plan", "計画ファイル作成",
  "実装計画", "タスク分割", "難易度判定", "サブタスクに分けて"
  使用場面:
  (1) 新機能の実装計画を立てる時
  (2) 大きなタスクをサブタスクに分解する時
  (3) 各タスクの難易度（Haiku/Sonnet）を判定して効率的に実装したい時
  (4) plans/ ディレクトリに計画ファイルを生成する時
---

# Smart Plan

会話コンテキストからタスクを読み取り、コードベースを調査し、タスクを細分化し、各サブタスクに難易度（Haiku / Sonnet）を割り当てて計画ファイルを生成する。実装フェーズでは適切なモデルで各タスクを実行する。

## 難易度判定基準

| レベル | モデル | 基準 |
|--------|--------|------|
| **🟢 Haiku** | `haiku` | 単純な変更、パターンの繰り返し、定型的なコード生成、テスト追加、リネーム、型修正 |
| **🔵 Sonnet** | `sonnet` | 設計判断が必要、複数ファイルにまたがる変更、新しいロジックの実装、バグ調査、リファクタリング |

## ワークフロー

### Step 1: コードベース探索

**Explore エージェントは使わない。** Grep / Glob を主体にコードベースを調査する。ygrep skill が利用可能な場合は優先的に使用してよい。

```bash
# Grep / Glob を使った検索
Grep("検索キーワード")                    # ファイル・関数・クラスの検索
Glob("**/*.ts")                          # ファイルパターン検索
Grep("query", type: "ts")               # TypeScript ファイルに絞る

# ygrep が利用可能な場合（補助的に使用）
ygrep "検索キーワード"
ygrep "query" -e ts -e tsx
```

調査対象:
- **プロジェクト構造**: ディレクトリ・モジュール・パッケージの配置
- **既存パターン**: 類似機能の実装方法
- **関連ファイル**: タスクに影響するファイル
- **依存関係**: ライブラリ・API・内部モジュール

CLAUDE.md が存在する場合は必ず読み込み、プロジェクト固有のルールを把握する。

探索せずに分解しない。

### Step 2: 主要コンポーネントの特定

タスク全体を大きなコンポーネントに分解する:
- どのような作業フェーズや領域があるか？
- コンポーネント間の依存関係は何か？
- どの順序で取り組むべきか？

### Step 3: 不明点のインタビュー

詳細なタスクを作成する前に、不明点をユーザーに確認する。

<rules>
- 全ての確認に AskUserQuestion ツールを使用する
- 明らかな質問はしない — ユーザーが考慮していない難しい部分を掘り下げる
- 1ラウンドあたり 2〜4 問
- 各質問には 2〜4 つの具体的な選択肢と簡単なメリット・デメリットを含める
- 「その他」は自動追加されるため含めない
- 分解に影響する不明点が解消されるまでインタビューを続ける
</rules>

<question_focus>
分解固有の懸念点に集中する:
- **スコープ**: X はこのタスクに含めるか、別タスクに分けるか？
- **アプローチ**: 既存コードの修正か、新規作成か？
- **順序**: X は Y の前に必須か、並列実行可能か？
- **粒度**: 1 タスクにするか、サブタスクに分割するか？
- **完了基準**: この作業エリアの「完了」とは何か？
- **リスク**: 不確実な領域に調査タスクを追加すべきか？
</question_focus>

### Step 4: 詳細タスクの作成

各コンポーネントに対してタスクを作成する:

<task_requirements>
**Specific（具体的）**
- 明確なアクション動詞（作成、追加、更新、削除、実装、設定など）
- 該当する場合は正確なファイルパスや場所
- 具体的な関数・クラス・コンポーネント名
- 期待する入力と出力

**Achievable（実行可能）**
- 外部ブロッカーなしに完了できる
- 実行に必要な情報がすべて揃っている
- 追加の確認が不要

**Small Enough（十分に小さい）**
- 完了まで約 5〜30 分
- 単一の責任に集中
- 独立して検証可能
</task_requirements>

各タスクの説明テンプレート:
```
**What**: [具体的なアクション]
**Where**: [正確なファイルパス、関数/クラス名、行番号範囲]
**How**: [コードベースの既存パターンを参照した実装アプローチ]
**Verify**: [具体的な検証手順 — テストコマンド、期待する出力、または手動確認手順]
```

### Step 5: 難易度判定

各タスクに Haiku または Sonnet を割り当てる。

**Haiku（🟢）に分類する条件:**
- 決まったパターンのコードを繰り返し追加する
- 変数・関数・ファイルのリネーム
- 型定義の修正・追加
- 既存パターンへのテスト追加
- 設定ファイルの定型的な変更
- 単一ファイル内の限定的な変更

**Sonnet（🔵）に分類する条件:**
- 設計・アーキテクチャの判断が必要
- 複数ファイルにまたがる変更
- 新しいロジック・アルゴリズムの実装
- バグの根本原因調査
- リファクタリング（責任の再設計）
- 外部 API・ライブラリとの統合
- 既存コードの挙動への影響分析が必要

### Step 6: ユーザーへの確認

AskUserQuestion ツールで、タスク一覧と難易度判定結果をユーザーに提示して確認を取る。

提示形式:
```
以下のタスク分解と実装方法を確認してください:

1. [Task subagent (haiku)] タスク名: 内容の概要
2. [Task subagent (sonnet)] タスク名: 内容の概要
3. [Task subagent (haiku)] タスク名: 内容の概要

この計画で進めますか？変更が必要な場合は教えてください。
```

選択肢:
1. この計画で進める
2. 一部のタスクの難易度判定を変更したい
3. タスクの追加・削除・分割をしたい

ユーザーの承認が得られるまで計画を修正する。

### Step 7: 計画ファイルの生成

承認後、プロジェクトの `plans/` ディレクトリに計画ファイルを作成する。

**命名規則**: `plans/[YYYY-MM-DD]-[連番]-[内容がわかるセンテンス].md`

例:
- `plans/2026-02-26-01-add-user-authentication.md`
- `plans/2026-02-26-02-refactor-api-client.md`

**ファイル形式**:

```markdown
# [計画タイトル]

## ✅ 実装状況

- [ ] タスク1：内容 → **Task subagent (haiku)**
- [ ] タスク2：内容 → **Task subagent (sonnet)**
- [ ] タスク3：内容 → **Task subagent (haiku)**

---

## 概要
[タスクの背景と目的]

## タスク詳細

### タスク1: [タイトル] → Task subagent (haiku)
- **What**: ...
- **Where**: ...
- **How**: ...
- **Verify**: ...

### タスク2: [タイトル] → Task subagent (sonnet)
- **What**: ...
- **Where**: ...
- **How**: ...
- **Verify**: ...

## 依存関係
- タスクX → タスクY（X完了後にY着手）

## 検証方法
- [全体の検証手順]
```

既存の連番を確認するために `plans/` ディレクトリの内容を確認してから連番を決定する。

### Step 8: 実装

計画ファイルを作成したら実装フェーズに移る。

**実装ルール**:
- 依存関係の順序を守る（依存元が完了してから依存先を開始）
- 独立したタスクは並列実行する（複数の Task ツール呼び出しを同一メッセージに含める）
- 各タスク完了後に計画ファイルの該当行を `[x]` に更新する
- Haiku タスクは `Task(model: "haiku")` で実行する
- Sonnet タスクは `Task(model: "sonnet")` で実行する

**並列実行の例** (独立したタスクが複数ある場合):
```
# 同一メッセージで複数の Task を呼び出す
Task(model: "haiku", prompt: "タスク1の詳細説明...")
Task(model: "sonnet", prompt: "タスク2の詳細説明...")
```

**Task プロンプトに含める情報**:
- 対象ファイルの正確なパス
- 実装する変更内容
- 参照すべき既存コードのパターン
- 検証方法

### Step 9: レビューとループ

全タスク完了後にレビューを実施:
- 元のタスクが全てカバーされているか？
- 各タスクに具体的な検証手順があるか？
- 残っている未解決の問題はないか？

ギャップや新たな曖昧さが見つかった場合は Step 3 に戻る。

## 重要な注意事項

- **探索してから分解する** — 読んでいないコードについて計画を立てない
- **具体的に記述する** — 曖昧なタスクは混乱を招く
- **エッジケースを考慮する** — エラー処理タスクを含める
- **順序を守る** — 依存関係を尊重してタスクを配置する
- **全タスクは検証可能にする** — 具体的なテストコマンドや確認手順を含める
- **実際のコードを参照する** — 実際のファイルパス・関数名・既存パターンを使用する
- **計画ファイルを更新する** — 各タスク完了時に `[x]` マークをつける
